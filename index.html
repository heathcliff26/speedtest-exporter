
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/speedtest-exporter/cmd/main.go (24.1%)</option>
				
				<option value="file1">github.com/heathcliff26/speedtest-exporter/pkg/cache/cache.go (86.8%)</option>
				
				<option value="file2">github.com/heathcliff26/speedtest-exporter/pkg/collector/collector.go (96.3%)</option>
				
				<option value="file3">github.com/heathcliff26/speedtest-exporter/pkg/collector/errors.go (0.0%)</option>
				
				<option value="file4">github.com/heathcliff26/speedtest-exporter/pkg/config/config.go (82.5%)</option>
				
				<option value="file5">github.com/heathcliff26/speedtest-exporter/pkg/config/duration.go (90.9%)</option>
				
				<option value="file6">github.com/heathcliff26/speedtest-exporter/pkg/config/errors.go (0.0%)</option>
				
				<option value="file7">github.com/heathcliff26/speedtest-exporter/pkg/speedtest/mock-speedtest.go (0.0%)</option>
				
				<option value="file8">github.com/heathcliff26/speedtest-exporter/pkg/speedtest/speedtest-cli.go (78.6%)</option>
				
				<option value="file9">github.com/heathcliff26/speedtest-exporter/pkg/speedtest/speedtest-go.go (65.5%)</option>
				
				<option value="file10">github.com/heathcliff26/speedtest-exporter/pkg/speedtest/types.go (97.1%)</option>
				
				<option value="file11">github.com/heathcliff26/speedtest-exporter/pkg/speedtest/util.go (100.0%)</option>
				
				<option value="file12">github.com/heathcliff26/speedtest-exporter/pkg/version/version.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "strconv"
        "time"

        "github.com/heathcliff26/promremote/promremote"
        "github.com/heathcliff26/speedtest-exporter/pkg/cache"
        "github.com/heathcliff26/speedtest-exporter/pkg/collector"
        "github.com/heathcliff26/speedtest-exporter/pkg/config"
        "github.com/heathcliff26/speedtest-exporter/pkg/speedtest"
        "github.com/heathcliff26/speedtest-exporter/pkg/version"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        configPath  string
        env         bool
        showVersion bool
)

// Initialize the logger
func init() <span class="cov8" title="1">{
        flag.StringVar(&amp;configPath, "config", "", "Optional: Path to config file")
        flag.BoolVar(&amp;env, "env", false, "Used together with -config, when set will expand enviroment variables in config")
        flag.BoolVar(&amp;showVersion, "version", false, "Show the version information and exit")
}</span>

// Handle requests to the webroot.
// Serves static, human-readable HTML that provides a link to /metrics
func ServerRootHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        fmt.Fprint(w, "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome to speedtest-exporter&lt;/h1&gt;Click &lt;a href='/metrics'&gt;here&lt;/a&gt; to see metrics.&lt;/body&gt;&lt;/html&gt;")
}</span>

func createSpeedtest(path string) (speedtest.Speedtest, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                slog.Debug("Using go-native speedtest implementation")
                return speedtest.NewSpeedtest(), nil
        }</span> else<span class="cov8" title="1"> {
                slog.Debug("Using external speedtest-cli binary", "path", path)
                return speedtest.NewSpeedtestCLI(path)
        }</span>
}

func createServer(port int, reg *prometheus.Registry) *http.Server <span class="cov8" title="1">{
        router := http.NewServeMux()
        router.HandleFunc("/", ServerRootHandler)
        router.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{Registry: reg}))

        return &amp;http.Server{
                Addr:        ":" + strconv.Itoa(port),
                Handler:     router,
                ReadTimeout: 10 * time.Second,
                // The speedtest takes roughly 22-24 seconds on average.
                // Ensure timeout has some buffer for a worst case.
                WriteTimeout: 60 * time.Second,
        }
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()

        if showVersion </span><span class="cov0" title="0">{
                fmt.Print(version.Version())
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig(configPath, env)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Could not load configuration", slog.String("path", configPath), slog.String("err", err.Error()))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">s, err := createSpeedtest(cfg.SpeedtestCLI)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed initialize speedtest", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">resultCache := cache.NewCache(cfg.PersistCache, "/cache/speedtest-result.json", time.Duration(cfg.Cache))

        collector, err := collector.NewCollector(resultCache, s)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create collector", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        reg.MustRegister(collector)

        if cfg.Remote.Enable </span><span class="cov0" title="0">{
                rwClient, err := promremote.NewWriteClient(cfg.Remote.URL, cfg.Remote.Instance, "integrations/speedtest", reg)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to create remote write client", "err", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if cfg.Remote.Username != "" </span><span class="cov0" title="0">{
                        err := rwClient.SetBasicAuth(cfg.Remote.Username, cfg.Remote.Password)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to create remote_write client", "err", err)
                                os.Exit(1)
                        }</span>
                }

                <span class="cov0" title="0">slog.Info("Starting remote_write client", slog.String("interval", cfg.Cache.String()))
                rwQuit := make(chan bool)
                rwClient.Run(time.Duration(cfg.Cache), rwQuit)
                defer func() </span><span class="cov0" title="0">{
                        rwQuit &lt;- true
                        close(rwQuit)
                }</span>()
        }

        <span class="cov0" title="0">server := createServer(cfg.Port, reg)

        slog.Info("Starting http server", slog.String("addr", server.Addr))
        err = server.ListenAndServe()
        if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                slog.Error("Failed to start http server", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "io"
        "log/slog"
        "os"
        "sync"
        "time"

        "github.com/heathcliff26/speedtest-exporter/pkg/speedtest"
)

type Cache struct {
        persist      bool
        path         string
        cacheTime    time.Duration
        cachedResult *speedtest.SpeedtestResult

        sync.RWMutex
}

// Create a new Cache instance and try to initialize it from disk if persist is true.
// If the path is not writable, the cache will not persist to disk.
// This function does not fail if it cannot read from disk, it will just log the error.
func NewCache(persist bool, path string, cacheTime time.Duration) *Cache <span class="cov8" title="1">{
        cache := &amp;Cache{
                persist:   persist,
                path:      path,
                cacheTime: cacheTime,
        }

        if path == "" </span><span class="cov8" title="1">{
                cache.persist = false
        }</span>
        <span class="cov8" title="1">if !cache.persist </span><span class="cov8" title="1">{
                return cache
        }</span>

        // #nosec G302: Cache does not contain sensitive data, can be world readable
        <span class="cov8" title="1">f, err := os.OpenFile(cache.path, os.O_CREATE|os.O_RDWR, 0644)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("Failed to open cache file, will not persist cache to disk", slog.String("file", cache.path), slog.Any("error", err))
                cache.persist = false
                return cache
        }</span>
        <span class="cov8" title="1">defer f.Close()

        data, err := io.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("Could not initialize cache from disk", slog.String("file", cache.path), slog.Any("error", err))
                return cache
        }</span>

        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov0" title="0">{
                slog.Info("Cache file is empty, starting with empty cache", slog.String("file", cache.path))
                return cache
        }</span>

        <span class="cov8" title="1">cachedResult := &amp;speedtest.SpeedtestResult{}
        err = cachedResult.UnmarshalJSON(data)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("Could not unmarshal cache data from disk", slog.String("file", cache.path), slog.Any("error", err))
        }</span> else<span class="cov8" title="1"> {
                slog.Info("Initialized cache from disk", slog.String("path", cache.path))
                cache.cachedResult = cachedResult
        }</span>
        <span class="cov8" title="1">return cache</span>
}

// Return the currently cached result and whether it is still valid.
// This method is safe to call even if the Cache instance is nil.
func (c *Cache) Read() (result *speedtest.SpeedtestResult, valid bool) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">c.RLock()
        defer c.RUnlock()

        if c.cachedResult == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">timestamp := c.cachedResult.TimestampAsTime()

        return c.cachedResult, timestamp.Add(c.cacheTime).After(time.Now())</span>
}

// Save the given result to the cache.
// Attempt to persist to disk if enabled, but do not fail if it fails.
// This method is safe to call even if the Cache instance is nil.
func (c *Cache) Save(result *speedtest.SpeedtestResult) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c.Lock()
        defer c.Unlock()

        c.cachedResult = result
        if !c.persist </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">data, err := result.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Could not marshal result to JSON", slog.Any("error", err))
                return
        }</span>
        // #nosec G306: Cache does not contain sensitive data, can be world readable
        <span class="cov8" title="1">err = os.WriteFile(c.path, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Could not write cache to disk", slog.String("file", c.path), slog.Any("error", err))
        }</span>
}

// Return when the cache will expire
func (c *Cache) ExpiresAt() time.Time <span class="cov8" title="1">{
        if c == nil || c.cachedResult == nil </span><span class="cov8" title="1">{
                return time.Time{}
        }</span>
        <span class="cov8" title="1">c.RLock()
        defer c.RUnlock()

        timestamp := c.cachedResult.TimestampAsTime()
        return timestamp.Add(c.cacheTime)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package collector

import (
        "log/slog"
        "sync"

        "github.com/heathcliff26/speedtest-exporter/pkg/cache"
        "github.com/heathcliff26/speedtest-exporter/pkg/speedtest"
        "github.com/prometheus/client_golang/prometheus"
)

type Collector struct {
        cache     *cache.Cache
        speedtest speedtest.Speedtest
}

var (
        variableLabels    = []string{"ip", "isp"}
        jitterLatencyDesc = prometheus.NewDesc("speedtest_jitter_latency_milliseconds", "Speedtest current Jitter in ms", variableLabels, nil)
        pingDesc          = prometheus.NewDesc("speedtest_ping_latency_milliseconds", "Speedtest current Ping in ms", variableLabels, nil)
        downloadSpeedDesc = prometheus.NewDesc("speedtest_download_megabits_per_second", "Speedtest current Download Speed in Mbit/s", variableLabels, nil)
        uploadSpeedDesc   = prometheus.NewDesc("speedtest_upload_megabits_per_second", "Speedtest current Upload Speed in Mbit/s", variableLabels, nil)
        dataUsedDesc      = prometheus.NewDesc("speedtest_data_used_megabytes", "Data used for speedtest in MB", variableLabels, nil)
        upDesc            = prometheus.NewDesc("speedtest_up", "Indicates if the speedtest was successful", nil, nil)
)

// Used to prevent concurrent runs of Speedtest's
var speedtestMutex sync.Mutex

// Create new instance of collector, returns error if an instance of speedtest is not provided
// Arguments:
//
//        cacheTime: Minimum time between speedtest runs
//        instance: Name of this instance, provided as label on all metrics
//        speedtest: Instance of speedtest to use for collection metrics
func NewCollector(cache *cache.Cache, speedtest speedtest.Speedtest) (*Collector, error) <span class="cov8" title="1">{
        if speedtest == nil </span><span class="cov8" title="1">{
                return nil, ErrNoSpeedtest{}
        }</span>
        <span class="cov8" title="1">return &amp;Collector{
                cache:     cache,
                speedtest: speedtest,
        }, nil</span>
}

// Implements the Describe function for prometheus.Collector
func (c *Collector) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov0" title="0">{
        prometheus.DescribeByCollect(c, ch)
}</span>

// Concurrency safe function to get the latest result of the speedtest.
// Will either return the cached result or run a new test.
func (c *Collector) getSpeedtestResult() *speedtest.SpeedtestResult <span class="cov8" title="1">{
        // Lock here to prevent running more than one Speedtest at a time, since they would affect each others results
        speedtestMutex.Lock()
        defer speedtestMutex.Unlock()

        result, ok := c.cache.Read()
        if ok </span><span class="cov8" title="1">{
                slog.Debug("Cache has not expired, returning cached results", slog.String("expires", c.cache.ExpiresAt().Local().String()))
                return result
        }</span>
        <span class="cov8" title="1">slog.Debug("Cache expired, running new Speedtest")
        result = c.speedtest.Speedtest()
        c.cache.Save(result)
        return result</span>
}

// Implements the Collect function for prometheus.Collector
func (c *Collector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        slog.Debug("Starting collection of speedtest metrics")
        result := c.getSpeedtestResult()
        var up float64
        if result.Success() </span><span class="cov8" title="1">{
                up = 1
                labelValues := []string{result.ClientIP(), result.ClientISP()}
                ch &lt;- prometheus.MustNewConstMetric(jitterLatencyDesc, prometheus.GaugeValue, result.JitterLatency(), labelValues...)
                ch &lt;- prometheus.MustNewConstMetric(pingDesc, prometheus.GaugeValue, result.Ping(), labelValues...)
                ch &lt;- prometheus.MustNewConstMetric(downloadSpeedDesc, prometheus.GaugeValue, result.DownloadSpeed(), labelValues...)
                ch &lt;- prometheus.MustNewConstMetric(uploadSpeedDesc, prometheus.GaugeValue, result.UploadSpeed(), labelValues...)
                ch &lt;- prometheus.MustNewConstMetric(dataUsedDesc, prometheus.GaugeValue, result.DataUsed(), labelValues...)
        }</span>
        <span class="cov8" title="1">ch &lt;- prometheus.MustNewConstMetric(upDesc, prometheus.GaugeValue, up)
        slog.Debug("Finished collection of speedtest metrics")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package collector

type ErrNoSpeedtest struct{}

func (e ErrNoSpeedtest) Error() string <span class="cov0" title="0">{
        return "No valid speedtest provided"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "log/slog"
        "os"
        "strings"
        "time"

        "github.com/heathcliff26/promremote/promremote"
        "sigs.k8s.io/yaml"
)

const (
        DEFAULT_LOG_LEVEL     = "info"
        DEFAULT_PORT          = 8080
        DEFAULT_CACHE         = Duration(5 * time.Minute)
        DEFAULT_PERSIST_CACHE = true
)

var logLevel *slog.LevelVar

// Initialize the logger
func init() <span class="cov8" title="1">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        LogLevel     string       `json:"logLevel,omitempty"`
        Port         int          `json:"port,omitempty"`
        Cache        Duration     `json:"cache,omitempty"`
        PersistCache bool         `json:"persistCache,omitempty"`
        SpeedtestCLI string       `json:"speedtestCLI,omitempty"`
        Remote       RemoteConfig `json:"remote,omitempty"`
}

type RemoteConfig struct {
        Enable   bool   `json:"enable"`
        URL      string `json:"url"`
        Instance string `json:"instance"`
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`
}

// Returns a Config with default values set
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                LogLevel:     DEFAULT_LOG_LEVEL,
                Port:         DEFAULT_PORT,
                Cache:        DEFAULT_CACHE,
                PersistCache: DEFAULT_PERSIST_CACHE,
        }
}</span>

// Loads config from file, returns error if config is invalid
// Arguments:
//
//        path: Path to config file
//        mode: Mode used, determines how the config will be validated and which values will be processed
//        env: Determines if enviroment variables in the file will be expanded before decoding
func LoadConfig(path string, env bool) (Config, error) <span class="cov8" title="1">{
        c := DefaultConfig()

        if path == "" </span><span class="cov8" title="1">{
                _ = setLogLevel(DEFAULT_LOG_LEVEL)
                return c, nil
        }</span>

        // #nosec G304: Local users can decide on the config file path freely.
        <span class="cov8" title="1">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">if env </span><span class="cov8" title="1">{
                f = []byte(os.ExpandEnv(string(f)))
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">if c.Remote.Enable </span><span class="cov8" title="1">{
                if c.Remote.URL == "" </span><span class="cov8" title="1">{
                        return Config{}, promremote.ErrMissingEndpoint{}
                }</span>
                <span class="cov8" title="1">if c.Remote.Username != c.Remote.Password &amp;&amp; (c.Remote.Username == "" || c.Remote.Password == "") </span><span class="cov8" title="1">{
                        return Config{}, promremote.ErrMissingAuthCredentials{}
                }</span>
                <span class="cov8" title="1">if c.Remote.Instance == "" </span><span class="cov0" title="0">{
                        slog.Info("No instance name provided, defaulting to hostname")
                        hostname, err := os.Hostname()
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to retrieve hostname, using localhost instead", "err", err)
                                hostname = "localhost"
                        }</span>
                        <span class="cov0" title="0">c.Remote.Instance = hostname</span>
                }
        }

        <span class="cov8" title="1">return c, nil</span>
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov8" title="1">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov8" title="1">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov8" title="1">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov8" title="1">
                return &amp;ErrUnknownLogLevel{level}</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "encoding/json"
        "time"
)

// Custom wrapper around time.Duration to implement json marshalling
type Duration time.Duration

func (d *Duration) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var s string
        err := json.Unmarshal(b, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">res, err := time.ParseDuration(s)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">*d = Duration(res)

        return nil</span>
}

func (d Duration) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(d.String())
}</span>

func (d Duration) String() string <span class="cov8" title="1">{
        return time.Duration(d).String()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import "time"

type ErrUnknownLogLevel struct {
        Level string
}

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.Level
}</span>

type ErrInvalidInterval struct {
        Interval time.Duration
}

func (e *ErrInvalidInterval) Error() string <span class="cov0" title="0">{
        return "Interval is to short, needs to be at least 30s, current " + e.Interval.String()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package speedtest

type MockSpeedtest struct {
        Callback func()
        Fail     bool
        Result   *SpeedtestResult
}

func (s *MockSpeedtest) Speedtest() *SpeedtestResult <span class="cov0" title="0">{
        if s.Callback != nil </span><span class="cov0" title="0">{
                s.Callback()
        }</span>
        <span class="cov0" title="0">if s.Fail </span><span class="cov0" title="0">{
                return NewFailedSpeedtestResult()
        }</span>
        <span class="cov0" title="0">return s.Result</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package speedtest

import (
        "bytes"
        "encoding/json"
        "errors"
        "log/slog"
        "os/exec"
        "strconv"
        "time"
)

type SpeedtestCLI struct {
        path string
}

// Create SpeedtestCLI, fails when it can't find the speedtest-cli binary
// Arguments:
//
//        executable: name or full path to speedtest-cli binary
func NewSpeedtestCLI(executable string) (*SpeedtestCLI, error) <span class="cov8" title="1">{
        path, err := exec.LookPath(executable)
        if errors.Is(err, exec.ErrDot) </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;SpeedtestCLI{
                path: path,
        }, nil</span>
}

// Get path of the speedtest-cli binary
func (s *SpeedtestCLI) Path() string <span class="cov8" title="1">{
        return s.path
}</span>

var makeCmd = func(path string) *exec.Cmd <span class="cov0" title="0">{
        return exec.Command(path, "--format=json-pretty", "--accept-license", "--accept-gdpr")
}</span>

// Execute the speedtest-cli binary and parse the result
func (s *SpeedtestCLI) Speedtest() *SpeedtestResult <span class="cov8" title="1">{
        start := time.Now()

        cmd := makeCmd(s.Path())
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Could not execute speedtest", "error", err, slog.String("stdout", stdout.String()), slog.String("stderr", stderr.String()))
                return NewFailedSpeedtestResult()
        }</span>

        <span class="cov8" title="1">var out resultJSON
        err = json.Unmarshal(stdout.Bytes(), &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Parsing JSON output from speedtest failed", "error", err, slog.String("output", stdout.String()))
                return NewFailedSpeedtestResult()
        }</span>

        <span class="cov8" title="1">downloadMbps := convertBytesToMbits(out.Download.Bandwidth)
        uploadMbps := convertBytesToMbits(out.Upload.Bandwidth)
        dataUsed := convertBytesToMB(out.Download.Bytes) + convertBytesToMB(out.Upload.Bytes)

        res := NewSpeedtestResult(out.Ping.Jitter, out.Ping.Latency, downloadMbps, uploadMbps, dataUsed, strconv.Itoa(out.Server.Id), out.Server.Host, out.ISP, out.Interface.ExternalIP)

        printSuccessMessage(res, time.Since(start))

        return res</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package speedtest

import (
        "log/slog"
        "time"

        "github.com/showwin/speedtest-go/speedtest"
)

type SpeedtestGo struct {
}

// Create instance of Speedtest
func NewSpeedtest() *SpeedtestGo <span class="cov8" title="1">{
        return &amp;SpeedtestGo{}
}</span>

// Use the speedtest-go api to run a speedtest and parse the result
func (s *SpeedtestGo) Speedtest() *SpeedtestResult <span class="cov8" title="1">{
        start := time.Now()

        client := speedtest.New()

        serverList, err := client.FetchServers()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Could not fetch server list", "error", err)
                return NewFailedSpeedtestResult()
        }</span>
        <span class="cov8" title="1">targets, err := serverList.FindServer([]int{})
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to find closest server", "error", err)
                return NewFailedSpeedtestResult()
        }</span>
        <span class="cov8" title="1">if len(targets) != 1 </span><span class="cov0" title="0">{
                slog.Error("FindServer returned more than one server")
                return NewFailedSpeedtestResult()
        }</span>
        <span class="cov8" title="1">server := targets[0]

        err = server.TestAll()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to run speedtest", "error", err)
                return NewFailedSpeedtestResult()
        }</span>
        <span class="cov8" title="1">user, err := client.FetchUserInfo()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to fetch client information", "error", err)
                return NewFailedSpeedtestResult()
        }</span>

        <span class="cov8" title="1">downloadMbps := convertBytesToMbits(server.DLSpeed)
        uploadMbps := convertBytesToMbits(server.ULSpeed)
        dataUsed := convertBytesToMB(server.Context.GetTotalDownload()) + convertBytesToMB(server.Context.GetTotalUpload())

        res := NewSpeedtestResult(float64(server.Jitter.Milliseconds()), float64(server.Latency.Milliseconds()), downloadMbps, uploadMbps, dataUsed, server.ID, server.Host, user.Isp, user.IP)

        printSuccessMessage(res, time.Since(start))

        return res</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package speedtest

import (
        "encoding/json"
        "time"
)

type Speedtest interface {
        Speedtest() *SpeedtestResult
}

type SpeedtestResult struct {
        jitterLatency float64 // ms
        ping          float64 // ms
        downloadSpeed float64 // Mbit/s
        uploadSpeed   float64 // Mbit/s
        dataUsed      float64 // MB
        serverID      string
        serverHost    string
        clientISP     string
        clientIP      string
        success       bool
        timestamp     int64
}

// Create a new SpeedtestResult for a failed speedtest.
func NewFailedSpeedtestResult() *SpeedtestResult <span class="cov8" title="1">{
        return &amp;SpeedtestResult{
                success:   false,
                timestamp: time.Now().UnixMilli(),
        }
}</span>

// Create a new SpeedtestResult from a successful speedrun
func NewSpeedtestResult(jitterLatency, ping, downloadSpeed, uploadSpeed, dataUsed float64, serverID, serverHost, clientISP, clientIP string) *SpeedtestResult <span class="cov8" title="1">{
        return &amp;SpeedtestResult{
                jitterLatency: jitterLatency,
                ping:          ping,
                downloadSpeed: downloadSpeed,
                uploadSpeed:   uploadSpeed,
                dataUsed:      dataUsed,
                serverID:      serverID,
                serverHost:    serverHost,
                clientISP:     clientISP,
                clientIP:      clientIP,
                success:       true,
                timestamp:     time.Now().UnixMilli(),
        }
}</span>

// Jitter latency of ping in ms
func (r *SpeedtestResult) JitterLatency() float64 <span class="cov8" title="1">{
        return r.jitterLatency
}</span>

// Ping in ms
func (r *SpeedtestResult) Ping() float64 <span class="cov8" title="1">{
        return r.ping
}</span>

// Download speed in Mbps
func (r *SpeedtestResult) DownloadSpeed() float64 <span class="cov8" title="1">{
        return r.downloadSpeed
}</span>

// Upload speed in Mbps
func (r *SpeedtestResult) UploadSpeed() float64 <span class="cov8" title="1">{
        return r.uploadSpeed
}</span>

// Data usage of speedtest in MB
func (r *SpeedtestResult) DataUsed() float64 <span class="cov8" title="1">{
        return r.dataUsed
}</span>

// ID of the speedtest server used for the test
func (r *SpeedtestResult) ServerID() string <span class="cov8" title="1">{
        return r.serverID
}</span>

// Name of the speedtest server used for the test
func (r *SpeedtestResult) ServerHost() string <span class="cov8" title="1">{
        return r.serverHost
}</span>

// ISP name of the client/connection
func (r *SpeedtestResult) ClientISP() string <span class="cov8" title="1">{
        return r.clientISP
}</span>

// Public IP of the client/connection
func (r *SpeedtestResult) ClientIP() string <span class="cov8" title="1">{
        return r.clientIP
}</span>

// Indicates if the test was successful
func (r *SpeedtestResult) Success() bool <span class="cov8" title="1">{
        return r.success
}</span>

// Returns the timestamp of when the speedtest was run.
// The timestamp is represented as milliseconds since the Unix epoch.
func (r *SpeedtestResult) Timestamp() int64 <span class="cov8" title="1">{
        return r.timestamp
}</span>

// Returns the timestamp of when the speedtest was run as time.Time
func (r *SpeedtestResult) TimestampAsTime() time.Time <span class="cov8" title="1">{
        return time.UnixMilli(r.timestamp)
}</span>

// Used for testing purposes only.
// Sets the timestamp of the speedtest result to the given time.
func (r *SpeedtestResult) DebugSetTimestamp(ts time.Time) <span class="cov0" title="0">{
        r.timestamp = ts.UnixMilli()
}</span>

// MarshalJSON implements json.Marshaler so the (unexported) fields of
// SpeedtestResult can be serialized with meaningful JSON keys.
func (r *SpeedtestResult) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type jsonAlias struct {
                JitterLatency float64 `json:"jitter_latency_ms"`
                Ping          float64 `json:"ping_ms"`
                DownloadSpeed float64 `json:"download_mbps"`
                UploadSpeed   float64 `json:"upload_mbps"`
                DataUsed      float64 `json:"data_used_mb"`
                ServerID      string  `json:"server_id"`
                ServerHost    string  `json:"server_host"`
                ClientISP     string  `json:"client_isp"`
                ClientIP      string  `json:"client_ip"`
                Success       bool    `json:"success"`
                Timestamp     int64   `json:"timestamp"`
        }

        a := jsonAlias{
                JitterLatency: r.jitterLatency,
                Ping:          r.ping,
                DownloadSpeed: r.downloadSpeed,
                UploadSpeed:   r.uploadSpeed,
                DataUsed:      r.dataUsed,
                ServerID:      r.serverID,
                ServerHost:    r.serverHost,
                ClientISP:     r.clientISP,
                ClientIP:      r.clientIP,
                Success:       r.success,
                Timestamp:     r.timestamp,
        }

        return json.MarshalIndent(a, "", "  ")
}</span>

// UnmarshalJSON implements json.Unmarshaler so JSON with the same keys used
// in MarshalJSON can be decoded back into a SpeedtestResult with unexported fields.
func (r *SpeedtestResult) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type jsonAlias struct {
                JitterLatency float64 `json:"jitter_latency_ms"`
                Ping          float64 `json:"ping_ms"`
                DownloadSpeed float64 `json:"download_mbps"`
                UploadSpeed   float64 `json:"upload_mbps"`
                DataUsed      float64 `json:"data_used_mb"`
                ServerID      string  `json:"server_id"`
                ServerHost    string  `json:"server_host"`
                ClientISP     string  `json:"client_isp"`
                ClientIP      string  `json:"client_ip"`
                Success       bool    `json:"success"`
                Timestamp     int64   `json:"timestamp"`
        }

        var a jsonAlias
        if err := json.Unmarshal(data, &amp;a); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">r.jitterLatency = a.JitterLatency
        r.ping = a.Ping
        r.downloadSpeed = a.DownloadSpeed
        r.uploadSpeed = a.UploadSpeed
        r.dataUsed = a.DataUsed
        r.serverID = a.ServerID
        r.serverHost = a.ServerHost
        r.clientISP = a.ClientISP
        r.clientIP = a.ClientIP
        r.success = a.Success
        r.timestamp = a.Timestamp

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package speedtest

import (
        "log/slog"
        "time"

        "github.com/showwin/speedtest-go/speedtest"
        "golang.org/x/exp/constraints"
)

type Number interface {
        constraints.Integer | speedtest.ByteRate
}

// Convert unit bytes to megabits
func convertBytesToMbits[T Number](bytes T) float64 <span class="cov8" title="1">{
        return convertBytesToMB(bytes) * 8
}</span>

// Convert unit bytes to megabytes
func convertBytesToMB[T Number](bytes T) float64 <span class="cov8" title="1">{
        return float64(bytes) / speedtest.MB
}</span>

// Print the log message for a successful speedtest
func printSuccessMessage(res *SpeedtestResult, elapsedTime time.Duration) <span class="cov8" title="1">{
        slog.Info("Successfully ran speedtest",
                slog.Float64("jitterLatency", res.JitterLatency()),
                slog.Float64("ping", res.Ping()),
                slog.Float64("downloadSpeed", res.DownloadSpeed()),
                slog.Float64("uploadSpeed", res.UploadSpeed()),
                slog.Float64("dataUsed", res.DataUsed()),
                slog.String("serverID", res.ServerID()),
                slog.String("serverHost", res.ServerHost()),
                slog.String("isp", res.ClientISP()),
                slog.String("ip", res.ClientIP()),
                slog.Duration("took", elapsedTime),
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package version

import (
        "runtime"
        "runtime/debug"
)

const Name = "speedtest-exporter"

// Return a formated string containing the version, git commit and go version the app was compiled with.
func Version() string <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov8" title="1">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov8" title="1"> if commit == "" </span><span class="cov8" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov8" title="1">result := Name + ":\n"
        result += "    Version: " + buildinfo.Main.Version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
